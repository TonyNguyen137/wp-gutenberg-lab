/* 
This file contains SCSS mixins sourced from the Bootstrap framework.
Source: https://github.com/twbs/bootstrap/tree/main/scss/mixins
These mixins are used in accordance with Bootstrap's open-source license (MIT).
Modifications may have been made to the original mixins.
*/
@use "sass:meta";
@use "sass:math";
@use "sass:map";
@use "sass:list";
@use "sass:string";
@use "sass:selector";
@use "functions" as *;
@use "variables" as *;

@mixin transition($transition...) {
	@if list.length($transition) == 0 {
		$transition: $transition-base;
	}

	@if list.length($transition) > 1 {
		@each $value in $transition {
			@if not $value or $value == none {
				@warn "The keyword 'none' or 'null' must be used as a single argument.";
			}
		}
	}

	@if $enable-transitions {
		@if list.nth($transition, 1) {
			transition: $transition;
		}

		@if $enable-reduced-motion and
			list.nth($transition, 1) and
			list.nth($transition, 1) !=
			none
		{
			@media (prefers-reduced-motion: reduce) {
				transition: none;
			}
		}
	}
}

// media query

@mixin mq($breakpoint, $config: ()) {
	$interaction-fine: fine;
	$interaction-coarse: coarse;
	$interaction-none: none;
	$has-media-hover: false;
	$_core-config: (
		grid-breakpoints: $grid-breakpoints,
		interaction: $interaction-none,
	);
	$_config: map.merge($_core-config, $config);
	$_grid-breakpoints: map.get($_config, grid-breakpoints);
	$_interaction: map.get($_config, interaction);

	// @debug $_grid-breakpoints;
	// @debug breakpoint $breakpoint;
	// @debug bool $breakpoint == xs;
	// @debug has-key map.has-key($_grid-breakpoints, $breakpoint);
	// @debug has-key and is xs (map.has-key($_grid-breakpoints, $breakpoint) and $breakpoint == xs);
	// @debug second ifelse map.get($_grid-breakpoints, $breakpoint);

	@if $breakpoint == xs {
		// do nothing
	} @else if map.has-key($_grid-breakpoints, $breakpoint) {
		$breakpoint-size: map.get($_grid-breakpoints, $breakpoint);

		@if $_interaction == $interaction-fine {
			@media screen and (min-width: $breakpoint-size) and (hover: hover) and (pointer: fine) {
				@content;
			}
		} @else if $_interaction == $interaction-coarse {
			@media screen and (min-width: $breakpoint-size) and (hover: none) and (pointer: coarse) {
				@content;
			}
		} @else {
			@media screen and (min-width: $breakpoint-size) {
				@content;
			}
		}
	} @else {
		@error 'the keyword #{$breakpoint} is not in the $breakpoints map';
	}
}

// Mixin: Media query for hover-capable devices at a specific breakpoint
// - Includes (hover: hover) and (pointer: fine) for precision
// - Falls back to a regular media query if $has-media-hover is false
// - Throws an error if the breakpoint is not defined in $grid-breakpoints
@mixin mq-hover-device($breakpoint) {
	@include mq($breakpoint, true);
}

@mixin respond-min($breakpoint) {
	@media (min-width: #{$breakpoint}px) {
		@content;
	}
}

@mixin make-container() {
	width: 100%;
	padding-inline: var(--container-padding, 12px);
	margin-inline: auto;
}

@mixin make-container-fluid-max($max-width) {
	max-width: $max-width;
	padding-inline: var(--container-padding, 12px);
	margin-inline: auto;
}

@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {
	$min: breakpoint-min($name, $breakpoints);

	// @debug min $min;
	@if $min {
		@media screen and (min-width: $min) {
			// @debug in media $min;

			@content;
		}
	} @else {
		// @debug kein media;

		@content;
	}
}

@mixin container-breakpoint-up($name, $breakpoints: $grid-breakpoints) {
	$min: breakpoint-min($name, $breakpoints);

	// @debug min $min;
	@if $min {
		@container (width > #{$min}) {
			@content;
		}
	}
}

// Bootstrap grid system
@mixin row-cols($count) {
	> * {
		flex: 0 0 auto;
		width: math.percentage(math.div(1, $count));
	}
}

@mixin make-row($gutter: $grid-gutter-width) {
	--#{$bs-prefix}gutter-x: #{$gutter};
	--#{$bs-prefix}gutter-y: 0;

	display: flex;
	flex-wrap: wrap;
	margin-top: calc(-1 * var(--#{$bs-prefix}gutter-y));
	margin-right: calc(-0.5 * var(--#{$bs-prefix}gutter-x));
	margin-left: calc(-0.5 * var(--#{$bs-prefix}gutter-x));
}

@mixin make-col-ready() {
	// Add box sizing if only the grid is loaded
	box-sizing: if(
		meta.variable-exists(include-column-box-sizing) and
			$include-column-box-sizing,
		border-box,
		null
	);

	// Prevent columns from becoming too narrow when at smaller grid tiers by
	// always setting `width: 100%;`. This works because we set the width
	// later on to override this initial width.
	flex-shrink: 0;
	width: 100%;
	max-width: 100%; // Prevent `.col-auto`, `.col` (& responsive variants) from breaking out the grid
	padding-right: calc(
		var(--#{$bs-prefix}gutter-x) * 0.5
	); // stylelint-disable-line function-disallowed-list
	padding-left: calc(
		var(--#{$bs-prefix}gutter-x) * 0.5
	); // stylelint-disable-line function-disallowed-list
	margin-top: var(--#{$bs-prefix}gutter-y);
}

@mixin make-col($size: false, $columns: $grid-columns) {
	@if $size {
		flex: 0 0 auto;
		width: math.percentage(math.div($size, $columns));
	} @else {
		flex: 1 1 0;
		max-width: 100%;
	}
}

@mixin make-col-auto() {
	flex: 0 0 auto;
	width: auto;
}

@mixin make-col-offset($size, $columns: $grid-columns) {
	$num: math.div($size, $columns);

	margin-left: if($num == 0, 0, math.percentage($num));
}

@mixin make-grid-columns(
	$columns: $grid-columns,
	$gutter: $grid-gutter-width,
	$breakpoints: $grid-breakpoints
) {
	@each $breakpoint in map.keys($breakpoints) {
		$infix: breakpoint-infix($breakpoint, $breakpoints);

		@include media-breakpoint-up($breakpoint, $breakpoints) {
			// Provide basic `.col-{bp}` classes for equal-width flexbox columns
			.col#{$infix} {
				flex: 1 0 0%; // Flexbugs #4: https://github.com/philipwalton/flexbugs#flexbug-4
			}

			.row-cols#{$infix}-auto > * {
				@include make-col-auto;
			}

			@if $grid-row-columns > 0 {
				@for $i from 1 through $grid-row-columns {
					.row-cols#{$infix}-#{$i} {
						@include row-cols($i);
					}
				}
			}

			.col#{$infix}-auto {
				@include make-col-auto;
			}

			@if $columns > 0 {
				@for $i from 1 through $columns {
					.col#{$infix}-#{$i} {
						@include make-col($i, $columns);
					}
				}

				// `$columns - 1` because offsetting by the width of an entire row isn't possible
				@for $i from 0 through ($columns - 1) {
					@if not($infix == "" and $i == 0) {
						// Avoid emitting useless .offset-0
						.offset#{$infix}-#{$i} {
							@include make-col-offset($i, $columns);
						}
					}
				}
			}

			@if $enable-gutters {
				@each $key, $value in $sizes-regular {
					.g#{$infix}-#{$key},
					.gx#{$infix}-#{$key} {
						--#{$bs-prefix}gutter-x: #{$value};
					}

					.g#{$infix}-#{$key},
					.gy#{$infix}-#{$key} {
						--#{$bs-prefix}gutter-y: #{$value};
					}
				}
			}
		}
	}
}

@mixin make-cssgrid($columns: $grid-columns, $breakpoints: $grid-breakpoints) {
	@each $breakpoint in map.keys($breakpoints) {
		$infix: breakpoint($breakpoint, $breakpoints);

		@include media-breakpoint-up($breakpoint, $breakpoints) {
			@if $columns > 0 {
				@for $i from 1 through $columns {
					.g-col#{$infix}-#{$i} {
						grid-column: auto / span $i;
					}
				}

				// Start with `1` because `0` is an invalid value.
				// Ends with `$columns - 1` because offsetting by the width of an entire row isn't possible.
				@for $i from 1 through ($columns - 1) {
					.g-start#{$infix}-#{$i} {
						grid-column-start: $i;
					}
				}
			}
		}
	}
}

@mixin generate-utility(
	$utility,
	$bp: "",
	$breakpoint-key,
	$key,
	$is-rfs-media-query: false
) {
	$values: map.get($utility, values);
	$selected-function: if(
		map.has-key($utility, function),
		map.get($utility, function),
		"default"
	);

	// Check if the list is not empty before accessing the first element
	@if list.length($values) > 0 and $values {
		// If the values are a list or string, convert it into a map
		@if meta.type-of($values) ==
			"string" or
			meta.type-of(list.nth($values, 1)) !=
			"list"
		{
			$values: list.zip($values, $values);
		}
	}

	// @debug values $values;
	// @debug meta.type-of($values);

	$is-important: if(map.get($utility, important), !important, null);
	$required-property: if(
		map.has-key($utility, required-property),
		map.get($utility, required-property),
		null
	);
	$property: map.get($utility, property);
	$custom-property-value: if(
		map.has-key($utility, custom-property-value),
		map.get($utility, custom-property-value),
		null
	);

	// @debug $custom-property-value;
	$class: map.get($utility, class);

	// Multiple properties are possible, for example with vertical or horizontal margins or paddings
	// @debug properties before $properties;

	@if meta.type-of($property) == "string" {
		$property: list.append((), $property);

		// @debug properties inside $properties;
	}

	// @debug properties after $properties;

	$local-vars: map.get($utility, local-vars);
	$is-rtl: map.get($utility, rtl);
	$custom-property-name: map.get($utility, custom-property-name);
	$nested-selectors: if(
		map.has-key($utility, complex-selectors),
		map.get($utility, complex-selectors),
		null
	);
	$complex-selectors: if(
		map.has-key($utility, complex-selectors),
		map.get($utility, complex-selectors),
		null
	);
	$state: map.get($utility, state);
	$custom-property-prefix: map.get($utility, custom-property-prefix);
	$css-variable-name: map.get($utility, css-variable-name);
	$media: map.get($utility, media);
	$has-hyphen: if(
		map.has-key($utility, has-hyphen),
		map.get($utility, has-hyphen),
		true
	);
	$responsive-custom-property-value: map.get(
		$utility,
		responsive-custom-property-value
	);
	$properties: map.get($utility, properties);
	$property-bindings: map.get($utility, property-bindings);
	$data-map: (
		breakpoint: $bp,
		breakpoint-key: $breakpoint-key,
		class: $class,
		custom-property-name: $custom-property-name,
		custom-property-value: $custom-property-value,
		custom-property-prefix: $custom-property-prefix,
		css-variable-name: $css-variable-name,
		has-hyphen: $has-hyphen,
		important: $is-important,
		is-rtl: $is-rtl,
		key: $key,
		local-vars: $local-vars,
		media: $media,
		property: $property,
		properties: $properties,
		property-bindings: $property-bindings,
		responsive-custom-property: $responsive-custom-property-value,
		required-property: $required-property,
		state: $state,
		values: $values,
	);

	@if $selected-function == "default" {
		@include create-default-utility($data-map);
	} @else if $selected-function == "fluid" {
		@include create-fluid-utility($data-map);
	} @else if $selected-function == "apply-custom-prop" {
		@include apply-custom-prop-utility($data-map);
	} @else if $selected-function == "apply-custom-props-at-breakpoints" {
		@include apply-custom-props-at-breakpoints-utility($data-map);
	} @else if $selected-function == "set-custom-prop" {
		@include set-custom-prop-utility($data-map);
	} @else if $selected-function == "apply-responsive-prop" {
		@include apply-responsive-prop-utility($data-map);
	} @else if $selected-function == "multi-prop" {
		@include create-multi-prop-utility($data-map);
	}
}

// @mixin apply-responsive-prop-utility($map) {
//   $responsive-custom-property: map.get($map, responsive-custom-property);
//   $property: map.get($map, property);
//   $important: map.get($map, important);
//   $breakpoint: map.get($map, breakpoint);
//   $breakpoint-key: map.get($map, breakpoint-key);
//   $class: map.get($map, class);
//   $key: map.get($map, key);
//   $properties-length: list.length($property);

//   // @debug responsive-custom-property $responsive-custom-property;
//   // @debug important $important;
//   // @debug breakpoint $breakpoint;
//   // @debug breakpoint-key $breakpoint-key;
//   // @debug class $class;
//   // @debug key $key;
//   // @debug properties-length $properties-length;

//   @if ($properties-length > 2) {
//     @error "#{$key} exceeds the maximum of 2 allowed properties. You provided #{$properties-length}.";
//   }
//   $breakpoint-key: if($breakpoint-key == '', $breakpoint-key, $breakpoint-key + '-');

//   .#{$breakpoint}#{$class} {
//     @if ($properties-length == 2) {
//       @each $prop in $property {
//         #{$prop}: var(--#{$breakpoint-key}#{$responsive-custom-property}) #{$important};
//       }
//     } @else {
//       #{$property}: var(--#{$breakpoint-key}#{$responsive-custom-property}) #{$important};
//     }
//   }
// }

@mixin generate-pattern(
	$pattern,
	$bp: "",
	$breakpoint-key,
	$key,
	$is-rfs-media-query: false
) {
	$values: map.get($pattern, values);
	$selected-function: if(
		map.has-key($pattern, function),
		map.get($pattern, function),
		"nested-pattern"
	);

	// Check if the list is not empty before accessing the first element
	@if list.length($values) > 0 and $values {
		// If the values are a list or string, convert it into a map
		@if meta.type-of($values) ==
			"string" or
			meta.type-of(list.nth($values, 1)) !=
			"list"
		{
			$values: list.zip($values, $values);
		}
	}

	// @debug values $values;
	// @debug meta.type-of($values);

	$is-important: if(map.get($pattern, important), !important, null);
	$required-property: if(
		map.has-key($pattern, required-property),
		map.get($pattern, required-property),
		null
	);
	$nesting: map.get($pattern, nesting);

	// @debug $custom-property-value;
	$class: map.get($pattern, class);
	$local-vars: map.get($pattern, local-vars);
	$is-rtl: map.get($pattern, rtl);
	$nested-selectors: if(
		map.has-key($pattern, complex-selectors),
		map.get($pattern, complex-selectors),
		null
	);
	$complex-selectors: if(
		map.has-key($pattern, complex-selectors),
		map.get($pattern, complex-selectors),
		null
	);
	$state: map.get($pattern, state);
	$media: map.get($pattern, media);
	$custom-properties: map.get($pattern, custom-properties);
	$data-map: (
		nesting: $nesting,
		values: $values,
		important: $is-important,
		required-property: $required-property,
		breakpoint: $bp,
		breakpoint-key: $breakpoint-key,
		class: $class,
		key: $key,
		custom-properties: $custom-properties,
		local-vars: $local-vars,
		is-rtl: $is-rtl,
		nested-selectors: $nested-selectors,
		state: $state,
		media: $media,
	);

	@if $selected-function == "nested-pattern" {
		@include create-nested-pattern($data-map);
	}
}

@mixin create-default-utility($map) {
	$property: map.get($map, property);
	$key: map.get($map, key);
	$values: map.get($map, values);
	$important: map.get($map, important);
	$breakpoint: map.get($map, breakpoint);
	$class: map.get($map, class);
	$local-vars: map.get($map, local-vars);
	$states: map.get($map, state);
	$states-length: if($states, list.length($states), null);
	$states: if($states-length == 1, to-list($states), $states);
	$css-var: map.get($map, css-var);
	$css-variable-name: map.get($map, css-variable-name);
	$required-property: map.get($map, required-property);
	$media: map.get($map, media);
	$has-hyphen: map.get($map, has-hyphen);

	// @debug -------normal-utility---------------;
	// @debug media $media;

	// @debug property $property;
	// @debug values $values;
	// @debug map.get($map, class);
	// @debug required-property $required-property;
	// @debug inportant $important;
	// @debug breakpoint $breakpoint;
	// @debug key $key;
	// @debug class $class;
	// @debug state $states;
	// @debug meta-state meta.type-of($states);
	// @debug state-length $states-length;
	// @debug local-vars $local-vars;
	// @debug css-var $css-var;
	// @debug css-variable-name $css-variable-name;
	// @debug --------------------------;

	@if $values {
		@if $states and $states-length > 1 {
			// @debug more than one state;
			@each $state in $states {
				@each $key, $value in $values {
					$key-suffix: if(
						$has-hyphen,
						null-safe-suffix($key),
						null-safe-value($key)
					);

					// @debug key-suffix $key-suffix;
					// @debug what type meta.type-of($breakpoint);
					// @debug breakpoint 1 $breakpoint;

					.#{$breakpoint}#{if($class, $class, $value)}#{$key-suffix}#{$state} {
						@if $local-vars {
							@each $local-var, $value in $local-vars {
								--#{$local-var}: #{$value};
							}
						}

						@if $required-property {
							@each $prop, $value in $required-property {
								#{$prop}: $value #{$important};
							}
						}

						@each $p in $property {
							// @debug property $property;
							#{$p}: $value #{$important};
						}
					}
				}
			}
		} @else {
			// @debug no state;

			@each $key, $value in $values {
				$key-suffix: if(
					$has-hyphen,
					null-safe-suffix($key),
					null-safe-value($key)
				);
				$single-state: single-or-null($states);

				// @debug key-suffix 2 $key-suffix;

				// @debug key $key;
				// @debug value $value;

				// @debug key-suffix $key-suffix;

				// @debug single-state $single-state;
				// @debug $breakpoint;
				// @debug meta.type-of($breakpoint);

				// @debug meta.type-of($breakpoint) == number;
				// $breakpoint: if(
				//   meta.type-of($breakpoint) == number,
				//   '\\'+ $breakpoint,
				//   $breakpoint
				// );

				// @debug new bp $breakpoint;

				.#{$breakpoint}#{if($class, $class, $key)}#{if($class, $key-suffix, '')}#{$single-state} {
					// @debug value hier- if($class, $class, $value);

					@if $local-vars {
						@each $local-var, $value in $local-vars {
							--#{$local-var}: #{$value};
						}
					}

					@if $required-property {
						@each $prop, $value in $required-property {
							#{$prop}: $value #{$important};
						}
					}

					@each $property in $property {
						@if $media {
							@media #{$media} {
								#{$property}: $value #{$important};
							}
						} @else {
							#{$property}: $value #{$important};
						}
					}
				}
			}
		}
	}
}

@mixin create-fluid-utility($map) {
	$property: map.get($map, property);
	$values: map.get($map, values);
	$important: map.get($map, important);
	$breakpoint: map.get($map, breakpoint);
	$class: map.get($map, class);
	$fluid-map: $values;

	// @debug -------- fluid ----------------;
	// @debug property $property;
	// @debug type-of property meta.type-of($property);
	// @debug property string #{$property};
	// @debug #{$property} == $property;
	// @debug font-size #{$property} == 'font-size';
	// @debug values $values;
	// @debug important $important;
	// @debug breakpoint $breakpoint;
	// @debug class $class;
	// @debug breakpoint $breakpoint;
	// @debug -------------------------;

	@if $values {
		// Loop through each key in the map
		@each $key in map.keys($fluid-map) {
			$map: map.get($fluid-map, $key);

			// @debug map $map;

			$selector-suffix: $key;

			// @debug selector-suffix $selector-suffix;
			$custom-property-name: $key;

			// @debug remove-prefix remove-prefix($key, 'fs-');

			$use-custom-property: if(
				map.has-key($map, create-custom-property),
				map.get($map, create-custom-property),
				true
			);

			// @debug use $use-custom-property;
			// @debug custom-property-name $custom-property-name;
			// @debug use-custom-property $use-custom-property;

			$threshold-map: map.get($map, threshold);

			// Get keys (the viewports)
			$viewports: map.keys($threshold-map);
			$min-viewport: list.nth($viewports, 1);
			$max-viewport: list.nth($viewports, 2);

			// @debug min-viewport $min-viewport;
			// @debug max-viewport $max-viewport;

			// Get sizes
			$min-size: map.get($threshold-map, $min-viewport);
			$max-size: map.get($threshold-map, $max-viewport);

			// @debug min-size $min-size;
			// @debug max-size $max-size;

			$threshold-unit: if(
				map.has-key($map, threshold-unit),
				map.get($map, threshold-unit),
				if(#{$property} == "font-size", "rem", "px")
			);
			$preferred-unit: if(
				map.has-key($map, preferred-unit),
				map.get($map, preferred-unit),
				"rem"
			);
			$relative-to: if(
				map.has-key($map, relative-to),
				map.get($map, relative-to),
				"viewport"
			);

			// @debug min-vp $min-viewport;
			// @debug max-vp $max-viewport;
			// @debug min-size $min-size;
			// @debug max-size $max-size;
			// @debug threshold-unit $threshold-unit;
			// @debug preferred-unit $preferred-unit;
			// @debug relative-to $relative-to;

			$breakpoint-prefix: breakpoint-prefix($breakpoint);

			@if $use-custom-property {
				// @debug inside;
				.#{$breakpoint}#{$class}-#{$selector-suffix} {
					@each $prop in $property {
						#{$prop}: var(--#{$cp-namespace}#{$custom-property-name})
							#{$important};
					}
				}
			} @else {
				.#{$breakpoint}#{$class}-#{$selector-suffix} {
					@each $prop in $property {
						#{$prop}: fluid(
								$min-size,
								$max-size,
								$min-viewport,
								$max-viewport,
								$threshold-unit,
								$preferred-unit,
								$relative-to
							)
							#{$important};
					}
				}
			}
		}
	}
}

@mixin apply-custom-prop-utility($map) {
	$property: map.get($map, property);
	$values: map.get($map, values);
	$custom-property-trunks: if($values, map.keys($values), "null");
	$custom-property-prefix: map.get($map, custom-property-prefix);
	$required-property: map.get($map, required-property);
	$formatted-prefix: add-hyphen($custom-property-prefix);
	$important: map.get($map, important);
	$breakpoint: map.get($map, breakpoint);
	$class: map.get($map, class);
	$local-vars: map.get($map, local-vars);
	$state: if(map.get($map, state), to-list(map.get($map, state)), null);

	// @debug property $property;
	// @debug values $values;
	// @debug required-property $required-property;
	// @debug prefix $custom-property-prefix;
	// @debug formatted-prefix $formatted-prefix;

	// @debug trunks $custom-property-trunks;

	// @debug important $important;
	// @debug breakpoint $breakpoint;
	// @debug class $class;
	// @debug state $state;

	// @debug breakpoint $breakpoint;
	// @debug local-vars $local-vars;

	@if $values {
		@if $formatted-prefix {
			@each $trunk in $custom-property-trunks {
				.#{$breakpoint}#{$class}-#{$trunk}#{$state} {
					@if $required-property {
						@each $prop, $value in $required-property {
							#{$prop}: $value #{$important};
						}
					}

					@each $prop in $property {
						#{$prop}: var(--#{$cp-namespace}#{$formatted-prefix}#{$trunk})
							#{$important};
					}
				}
			}
		} @else {
			@each $trunk, $value in $values {
				$formatted-trunk: add-hyphen(#{$trunk}, prepend);
				.#{$breakpoint}#{$class}#{$formatted-trunk}#{$state} {
					@if $required-property {
						@each $prop, $value in $required-property {
							#{$prop}: $value #{$important};
						}
					}

					@each $prop in $property {
						#{$prop}: $value #{$important};
					}
				}
			}
		}
	}
}

@mixin create-multi-prop-utility($map) {
	$key: map.get($map, key);
	$properties: map.get($map, properties);
	$values: map.get($map, values);
	$important: map.get($map, important);
	$breakpoint: map.get($map, breakpoint);
	$class: map.get($map, class);
	$local-vars: map.get($map, local-vars);
	$states: map.get($map, state);
	$states-length: if($states, list.length($states), null);
	$states: if($states-length == 1, to-list($states), $states);

	// @debug key $key;
	// @debug properties $properties;
	// @debug important $important;
	// @debug breakpoint $breakpoint;
	// @debug class $class;
	// @debug state $states;
	// @debug state-length $states-length;
	// @debug meta-state meta.type-of($states);
	// @debug local-vars $local-vars;
	// @debug join list.join($states, (), comma);
	// @debug states $states;
	// @debug length $states-length;

	@if $states and $states-length > 1 {
		$formatted-states: list.join($states, (), comma);

		// @debug $formatted-states;

		.#{$breakpoint}#{$class}:where(#{$formatted-states}) {
			@if $local-vars {
				@each $local-var, $value in $local-vars {
					--#{$local-var}: #{$value};
				}
			}

			@each $prop, $value in $properties {
				#{$prop}: $value #{$important};
			}
		}
	} @else {
		// Get single state from $states list, returns null if unset
		$single-state: single-or-null($states);

		.#{$breakpoint}#{$class}#{$single-state} {
			@if $local-vars {
				@each $local-var, $value in $local-vars {
					--#{$local-var}: #{$value};
				}
			}

			@each $prop, $value in $properties {
				#{$prop}: $value #{$important};
			}
		}
	}
}

@mixin apply-responsive-prop-utility($map) {
	$property-bindings: map.get($map, property-bindings);
	$important: map.get($map, important);
	$breakpoint: map.get($map, breakpoint);
	$breakpoint-key: map.get($map, breakpoint-key);
	$class: map.get($map, class);
	$key: map.get($map, key);

	// @debug responsive-custom-props $responsive-custom-props;
	// @debug important $important;
	// @debug breakpoint $breakpoint;
	// @debug breakpoint-key $breakpoint-key;
	// @debug class $class;

	$breakpoint-key: if(
		$breakpoint-key == "",
		$breakpoint-key,
		$breakpoint-key + "-"
	);

	.#{$breakpoint}#{$class} {
		@each $prop, $value in $property-bindings {
			#{$prop}: var(--#{$breakpoint-key}#{$value}) #{$important};
		}
	}
}

@mixin create-nested-pattern($map) {
	$nesting: map.get($map, nesting);
	$values: map.get($map, values);
	$important: map.get($map, important);
	$breakpoint: map.get($map, breakpoint);
	$class: map.get($map, class);
	$custom-properties: map.get($map, custom-properties);

	// @debug nesting $nesting;
	// @debug important $important;
	// @debug breakpoint $breakpoint;
	// @debug class $class;
	// @debug values $values;

	// @debug meta.type-of($values);

	@if $values and meta.type-of($values) == map {
		@each $key, $value in $values {
			.#{$breakpoint}#{$class}-#{$key} {
				// loop through custom properties

				@if $custom-properties and meta.type-of($custom-properties) == map {
					@each $name, $value in $custom-properties {
						--#{$name}: $value;
					}
				}

				@each $property, $property-value in $nesting {
					// @debug property $property;
					// @debug property-value $value;

					@if meta.type-of($property-value) == "map" {
						$_nested-selector: $property;

						#{$_nested-selector} {
							@each $nested-property, $nested-value in $property-value {
								$formatted-value: null;

								@if $nested-value == "" {
									$formatted-value: '""';
								} @else if $nested-value == VALUE {
									$formatted-value: $value;
								} @else {
									$formatted-value: $nested-value;
								}

								#{$nested-property}: #{$formatted-value};
							}
						}
					} @else {
						#{$property}: #{$value};
					}
				}
			}
		}
	} @else {
		.#{$breakpoint}#{$class} {
			// loop through custom properties
			@if $custom-properties and meta.type-of($custom-properties) == map {
				@each $name, $value in $custom-properties {
					--#{$name}: $value;
				}
			}

			// Loop through the nesting defined for each utility
			@each $property, $property-value in $nesting {
				@if meta.type-of($property-value) == "map" {
					$_nested-selector: $property;

					#{$_nested-selector} {
						@each $nested-property, $nested-value in $property-value {
							$formatted-value: if($nested-value == "", '""', $nested-value);

							#{$nested-property}: #{$formatted-value} #{$important};
						}
					}
				} @else {
					#{$property}: #{$property-value} #{$important};
				}
			}
		}
	}
}

@mixin set-custom-prop-utility($map) {
	$property: map.get($map, property);
	$key: map.get($map, key);
	$values: map.get($map, values);
	$important: map.get($map, important);
	$breakpoint: map.get($map, breakpoint);
	$class: if(map.get($map, class), map.get($map, class), $key);
	$local-vars: map.get($map, local-vars);
	$states: map.get($map, state);
	$states-length: if($states, list.length($states), null);
	$states: if($states-length == 1, to-list($states), $states);
	$css-variable-name: map.get($map, css-variable-name);
	$custom-property-trunks: if($values, map.keys($values), "null");
	$custom-property-prefix: map.get($map, custom-property-prefix);

	// @debug --------------------------;
	// @debug property $property;
	// @debug custom-property-trunks $custom-property-trunks;
	// @debug custom-property-prefix $custom-property-prefix;
	// @debug values $values;
	// @debug inportant $important;
	// @debug breakpoint $breakpoint;
	// @debug key $key;
	// @debug class $class;
	// @debug state $states;
	// @debug meta-state meta.type-of($states);
	// @debug state-length $states-length;
	// @debug local-vars $local-vars;
	// @debug css-variable-name $css-variable-name;
	// @debug --------------------------;

	@if $values {
		@if $states and $states-length > 1 {
			// @debug more than one state;
			@each $state in $states {
				@each $key, $value in $values {
					$key-suffix: null-safe-suffix($key);

					// @debug key-suffix $key-suffix;

					@if $custom-property-prefix {
						.#{$class}#{$breakpoint}#{$key-suffix}#{$state} {
							--#{$css-variable-name}: var(
								--#{$cp-namespace}#{$custom-property-prefix}#{$key-suffix}
							);
						}
					} @else {
						.#{$class}#{$breakpoint}#{$key-suffix}#{$state} {
							--#{$css-variable-name}: #{$value};
						}
					}
				}
			}
		} @else {
			@each $key, $value in $values {
				$key-suffix: null-safe-suffix($key);

				// @debug key $key;
				// @debug key-suffix $key-suffix;
				$single-state: single-or-null($states);

				// @debug $single-state;
				@if $custom-property-prefix {
					.#{$class}#{$breakpoint}#{$key-suffix}#{$single-state} {
						--#{$css-variable-name}: var(
							--#{$cp-namespace}#{$custom-property-prefix}#{$key}#{$single-state}
						);
					}
				} @else {
					// @debug single-state $single-state;
					.#{$class}#{$breakpoint}#{$key-suffix}#{$single-state} {
						--#{$css-variable-name}: #{$value};
					}
				}
			}
		}
	}
}

@mixin apply-custom-props-at-breakpoints-utility($map) {
	// @debug map $map;
	// @debug keys map.keys($map);
	// @debug HEER $map;

	$map: map.get($map, values);

	@if $map {
		@if list.length(map.keys($map)) > 0 {
			@each $key, $value-map in $map {
				$_class: if(
					map.has-key($value-map, class),
					map.get($value-map, class),
					$key
				);
				$_property: map.get($value-map, property);

				@if $_property {
					.#{$_class} {
						#{$_property}: var(--#{$cp-namespace}#{$key});
					}
				}
			}
		}
	}
}

@mixin generate-responsive-custom-properties($map) {
	// @debug map $map;
	// @debug bps map.keys($map);

	@each $breakpoint in map.keys($map) {
		// @debug bp $breakpoint;

		@include media-breakpoint-up($breakpoint) {
			// @debug inside media-bp-up $breakpoint;

			@if $breakpoint == "xs" {
				// @debug map map.get($map, $breakpoint);
				@each $custom-property-name, $value-object in map.get($map, $breakpoint)
				{
					// @debug custom-property-name $custom-property-name;
					// @debug value-object $value-object;
					// @debug ----------;
					--#{$cp-namespace}#{$custom-property-name}: #{map.get(
							$value-object,
							value
						)};
				}
			} @else {
				@each $custom-property-name, $value in map.get($map, $breakpoint) {
					// @debug in else;
					// @debug custom-property-name $custom-property-name;
					// @debug value $value;

					// @debug ----------;

					& {
						--#{$cp-namespace}#{$custom-property-name}: #{$value};
					}
				}
			}
		}
	}
}

@mixin generate-custom-properties($map: (), $local-namespace: "") {
	@if $map {
		@if map.has-key($map, custom-property-name) {
			$_name: map.get($map, custom-property-name);
			$_map: map.get($map, values);

			// @debug map 1 $_map;

			// convert to a map if $_map is a list
			$_map: if(meta.type-of($_map) == list, list.zip($_map, $_map), $_map);

			// @debug _name $_name;
			// @debug _map 2 $_map;

			@if $_map {
				@each $key, $value in $_map {
					// @debug key $key;
					// @debug value $value;

					@if $key != "none" {
						$_key: if($key, if($key == 0, "-0", -$key), "");

						--#{$cp-namespace}#{$local-namespace}#{$_name}#{$_key}: #{$value};
					}
				}
			}
		} @else if map.has-key($map, xs) {
			@each $key, $value in $map {
				@if $key != xs {
					--#{$cp-namespace}#{$local-namespace}#{$key}: #{$value};
				}
			}
		}
	}
}

@mixin generate-simple-custom-properties($map: ()) {
	@if $map {
		@if list.length(map.keys($map)) > 0 {
			@each $key, $value in $map {
				@if meta.type-of($value) == map {
					--#{$cp-namespace}#{$key}: #{map.get($value, value)};
				} @else {
					--#{$cp-namespace}#{$key}: #{$value};
				}
			}
		}
	}
}

@mixin generate-clamp-custom-properties(
	$clamp-map,
	$default-unit: "rem",
	$default-relative-to: "viewport"
) {
	// Only loop if the map has entries
	@if $clamp-map and list.length(map.keys($clamp-map)) > 0 {
		@each $key, $map in $clamp-map {
			$has-custom-property: if(
				map.has-key($map, create-custom-property),
				map.get($map, create-custom-property),
				true
			);

			@if $has-custom-property {
				$relative-to: if(
					map.has-key($map, relative-to),
					map.get($map, relative-to),
					$default-relative-to
				);
				$threshold-unit: if(
					map.has-key($map, threshold-unit),
					map.get($map, threshold-unit),
					$default-unit
				);
				$threshold-keys: map.keys(map.get($map, threshold));
				$threshold-map: map.get($map, threshold);
				$min-size: map.get($threshold-map, list.nth($threshold-keys, 1));
				$max-size: map.get($threshold-map, list.nth($threshold-keys, 2));

				// convert the keys to its corresponding pixel value. Otherwise, use the value as-is.
				$key-min-formatted: if(
					meta.type-of(list.nth($threshold-keys, 1)) ==
						"string" and
						map.has-key($grid-breakpoints, list.nth($threshold-keys, 1)),
					map.get($grid-breakpoints, list.nth($threshold-keys, 1)),
					list.nth($threshold-keys, 1)
				);
				$key-max-formatted: if(
					meta.type-of(list.nth($threshold-keys, 2)) ==
						"string" and
						map.has-key($grid-breakpoints, list.nth($threshold-keys, 2)),
					map.get($grid-breakpoints, list.nth($threshold-keys, 2)),
					list.nth($threshold-keys, 2)
				);
				$min-viewport: remove-unit-and-convert($key-min-formatted);
				$max-viewport: remove-unit-and-convert($key-max-formatted);
				$delta-size: $max-size - $min-size;
				$delta-viewport: $max-viewport - $min-viewport;
				$change: round-to(math.div($delta-size, $delta-viewport), 6);
				$preferred: round-to(
					math.div($max-size - ($max-viewport * $change), 16) * 1rem,
					4
				);
				$rate-of-change: null;

				@if $relative-to == "viewport" {
					$rate-of-change: round-to(100vw * $change);
				} @else if $relative-to == "container" {
					$rate-of-change: round-to(100cqi * $change);
				} @else {
					@error 'Invalid value for $relativeTo. Expected "viewport" or "container".';
				}

				$min-size: if(
					$threshold-unit == "rem",
					px-to-rem($min-size),
					$min-size * 1px
				);
				$max-size: if(
					$threshold-unit == "rem",
					px-to-rem($max-size),
					$max-size * 1px
				);

				--#{$cp-namespace}#{$key}: clamp(
					#{$min-size},
					calc(#{$preferred} + #{$rate-of-change}),
					#{$max-size}
				);
			}
		}
	}
}

@mixin generate-color-themes($color-theme, $removed-theme: "default") {
	// @debug color-theme $color-theme;
	// @debug meta.type-of($color-theme);

	$_theme-map: map.remove($color-theme, $removed-theme);

	// @debug _theme-map $_theme-map;
	// @debug meta meta.type-of($_theme-map);

	@each $theme, $color-map, $color-hover in $_theme-map {
		$colors: map.get($color-map, color);
		$colors-hover: if(
			map.get($color-map, hover),
			map.get($color-map, hover),
			()
		);

		// @debug theme $theme;
		// @debug color $colors;
		// @debug color-hover $colors-hover;

		[data-theme="#{$theme}"] {
			$colors-rgb: map-loop($colors, to-rgb, "$value");

			@include generate-color-custom-properties($colors, $color-prefix);
			@include generate-color-custom-properties-rgb($colors-rgb, $color-prefix);
			@include generate-color-custom-properties($colors-hover, $hover-prefix);
		}
	}
}

@mixin generate-color-custom-properties($color-theme, $color-prefix: "clr-") {
	// @debug meta.type-of($color-theme);

	@each $color-name, $value in $color-theme {
		@if meta.type-of($value) == "color" {
			--#{$cp-namespace}#{$color-prefix}#{$color-name}: #{$value};
		} @else {
			@error 'the color input is not correct';
		}
	}
}

@mixin generate-color-custom-properties-rgb(
	$color-theme-map: (),
	$color-prefix: "clr-"
) {
	// Only loop if the map has entries

	// @debug MAPP $color-theme-map;
	@if $color-theme-map and list.length(map.keys($color-theme-map)) > 0 {
		@each $color, $rgb-value in $color-theme-map {
			$type: meta.type-of($rgb-value);

			@if $type == "list" {
				// @debug color $color;
				// @debug rgb $rgb-value;

				--#{$cp-namespace}#{$color-prefix}#{$color}-rgb: #{$rgb-value};
			} @else {
				@error 'the color input is not correct';
			}
		}
	}
}

@mixin export-breakpoints-json(
	$grid-breakpoints,
	$prop-name: --js-breakpoints
) {
	$json: "{";
	$i: 0;
	$len: list.length($grid-breakpoints);
	$last-item-index: $len - 1;

	@each $key, $val in $grid-breakpoints {
		// Zahl in px ohne Einheit schreiben
		@if $key != xs {
			@if math.is-unitless($val) {
				@error 'your breakpoint: #{$key}:#{$val} is unitless!';
			}

			// @debug val $val;
			// @debug meta.type-of($val);
			$json: $json + '"' + $key + '":' + '"' + $val + '"';

			@if $i != $last-item-index {
				$json: $json + ",";
			}
		}

		$i: $i + 1;
	}

	$json: $json + "}";

	// $json: string.unquote($json);

	#{$prop-name}: "#{$json}";
}
